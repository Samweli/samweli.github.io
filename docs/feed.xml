<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.5">Jekyll</generator><link href="http://0.0.0.0:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://0.0.0.0:4000/" rel="alternate" type="text/html" /><updated>2025-05-28T00:03:53+00:00</updated><id>http://0.0.0.0:4000/feed.xml</id><title type="html">Embracing and exploring tech world</title><subtitle>Observing life from a software perspective.</subtitle><author><name>Samweli Mwakisambwe</name><email>smwltwesa6@gmail.com</email></author><entry><title type="html">Streamlining QGIS Development using Docker</title><link href="http://0.0.0.0:4000/QGIS-Development-Using-Docker/" rel="alternate" type="text/html" title="Streamlining QGIS Development using Docker" /><published>2025-05-27T00:00:00+00:00</published><updated>2025-05-27T00:00:00+00:00</updated><id>http://0.0.0.0:4000/-QGIS-Development-Using-Docker</id><content type="html" xml:base="http://0.0.0.0:4000/QGIS-Development-Using-Docker/"><![CDATA[<p><img src="../assets/images/qgis_in_docker.png" alt="" /></p>

<p>In recent years, the <a href="https://github.com/qgis/QGIS">QGIS Development team</a> has been building and sharing official 
QGIS <a href="https://www.docker.com">Docker</a> images via the <a href="https://hub.docker.com/r/qgis/qgis">QGIS Docker Hub</a> . This work has provided an effective and
reusable approach to running and setting up QGIS and its components across a wide variety of use cases and environments.
These Docker images have been useful for those looking to run unreleased versions (nightly builds and master branch changes)
of QGIS, create robust headless testing environments, facilitate the setup and compilation of QGIS development environments and 
 install/use multiple QGIS versions in one operating system (<strong>a topic for another blog post</strong>!!).</p>

<p>In this post, I’m going to share the benefits of using Docker when setting up QGIS development, and provide
a guide on how to start providing QGIS contributions. I will touch on the normal way of setting up QGIS development
and explain its difference compared to the suggested Docker-based approach.</p>

<p>The whole QGIS development workflow is 
a huge ecosystem containing various components, general practices and a number of tools <strong>similar to many other
big open source projects</strong>.
I’m not going to cover all of these here,
but I will address the high-level structure that anyone (even a beginner) can adopt and use for the development of core QGIS features.</p>

<h2 id="compiling-qgis-desktop">Compiling QGIS Desktop</h2>

<p>QGIS desktop core is mainly developed using C++ and the <a href="https://www.qt.io/product/framework">Qt framework</a>. The usual approach for compiling QGIS from source involves
downloading and installing various dependencies
and tools for the operating system. Necessary build tools are needed to be manually configured and processed in order to
compile QGIS from its source code.</p>

<p>For example, on Ubuntu 22.04, you would need to install a list of dependencies such as:</p>

<ul>
  <li><strong>Build Tools</strong>: <code class="language-plaintext highlighter-rouge">bison</code>, <code class="language-plaintext highlighter-rouge">build-essential</code>, <code class="language-plaintext highlighter-rouge">cmake</code>, <code class="language-plaintext highlighter-rouge">ccache</code>, <code class="language-plaintext highlighter-rouge">flex</code></li>
  <li><strong>Geospatial Libraries</strong>: <code class="language-plaintext highlighter-rouge">libgdal-dev</code>, <code class="language-plaintext highlighter-rouge">libgeos-dev</code>, <code class="language-plaintext highlighter-rouge">libproj-dev</code>, <code class="language-plaintext highlighter-rouge">libpq-dev</code></li>
  <li><strong>Qt and PyQt5</strong>: <code class="language-plaintext highlighter-rouge">libqt5opengl5-dev</code>, <code class="language-plaintext highlighter-rouge">libqt5serialport5-dev</code>, <code class="language-plaintext highlighter-rouge">python3-pyqt5</code></li>
  <li><strong>Python Dependencies</strong>: <code class="language-plaintext highlighter-rouge">python3-dev</code>, <code class="language-plaintext highlighter-rouge">python3-gdal</code>, <code class="language-plaintext highlighter-rouge">python3-lxml</code>, <code class="language-plaintext highlighter-rouge">python3-psycopg2</code></li>
  <li><strong>Additional Dependencies</strong>: <code class="language-plaintext highlighter-rouge">doxygen</code>, <code class="language-plaintext highlighter-rouge">graphviz</code>, <code class="language-plaintext highlighter-rouge">protobuf-compiler</code>, <code class="language-plaintext highlighter-rouge">libspatialindex-dev</code>, <code class="language-plaintext highlighter-rouge">qtbase5-dev</code></li>
</ul>

<div align="center">
  <img alt="a gif showing a long list of items" src="../assets/images/long_list.webp" />
  <p align="center">Long list ehh!!</p>
</div>

<p>This process involves not only installing the correct versions of all these packages but also managing 
potential conflicts between them. Additionally, maintaining these dependencies across different OS 
versions can be problematic, leading to frequent setup issues and the need for manual troubleshooting.</p>

<p>On top of that in some environments, developers may need to manually compile, install libraries and 
link them to QGIS by overriding the corresponding
default settings in the QGIS configuration files. This can happen if the required libraries versions aren’t 
available via system packages — a challenging task that should be avoided, especially for new contributors.</p>

<p>It would have been nice if the dependencies fetch could only feature a few set of consistent steps, this would help
the beginners to easily grasp the whole QGIS development setup workflow and skip past all the issues that come dealing 
with build tools installation.</p>

<p>For more info about QGIS compilation <a href="https://github.com/qgis/QGIS/blob/master/INSTALL.md">see</a>.</p>

<h2 id="why-use-docker">Why use Docker?</h2>

<p>The Docker approach makes it easier to set up a QGIS development environment, avoiding the challenges and
time-consuming tasks involved with manually installing all the required dependencies and configuring the system.
Developers only need to know how to use Docker in order to use the setup, no other extra skills are needed.</p>

<p>The main goal is to set up a workflow that intends to serve as a single, consistent process 
that operates reliably across all environments.</p>

<h2 id="benefits">Benefits</h2>

<p>With Docker, the complexity of setting up a QGIS development environment is drastically reduced. 
Docker containers allow you to package everything needed to run QGIS, including its dependencies, 
into a single environment. Here are some key benefits of using Docker for QGIS development:</p>

<h4 id="easy-setup">Easy setup</h4>
<p>Docker enables a “create once, run anywhere” approach. All the dependencies required to compile 
QGIS are bundled into the Docker image, huge thanks to QGIS development team for making this possible,
this simplifies the whole process of dependencies fetching QGIS development without
worrying about compatibility or dependency issues.</p>

<p>The only thing you need to run a Docker container
is Docker itself, which is available on most platforms.</p>

<h4 id="platform-independence">Platform independence</h4>
<p>One of Docker’s greatest advantages is that it abstracts away the underlying operating system. 
Whether you’re using Linux, macOS, or Windows, Docker ensures that the QGIS development environment
will be the same across all platforms. Eliminating the need to configure each OS individually and 
ensures consistency. The main reason for this is that some operating systems doesn’t support directly installation
of some QGIS dependencies hence not ensuring a standard one for all development configurations.</p>

<h4 id="reproducibility">Reproducibility</h4>
<p>Docker images ensure that you can share your development environment with others, making it easier for
collaborators or new contributors to get started. This reproducibility is essential in open-source projects like
QGIS, where contributors may come from a variety of environments. The docker environment setup specifically for this 
case includes a configuration file <code class="language-plaintext highlighter-rouge">docker-compose.yml</code> that can be shared with the target QGIS repository tag/branch
/commit and that should be enough to make it work in any other environment given the needed Docker images 
are available.</p>

<h4 id="headless-and-isolated-environment">Headless and isolated environment</h4>
<p>Docker allows you to run QGIS in a headless, isolated environment, which is ideal for continuous integration,
automated testing, and in environments where you don’t have graphical interface unit.</p>

<h4 id="simplified-compilation">Simplified compilation</h4>
<p>Instead of manually managing and installing dependencies, the Docker image for QGIS comes 
pre-configured with everything you need. This allows you to focus on development rather than spending
hours troubleshooting setup issues.</p>

<h2 id="docker-in-action">Docker in action</h2>

<p>Now that we have seen the rationale behind using Docker for setting up QGIS development and its general 
benefits, lets take a look 
at the actual work and the required steps to set Docker and spin up QGIS from it.</p>

<div align="center">
  <img alt="a gif showing a team about to work" src="../assets/images/lets_do_this.gif" />
</div>

<h3 id="prerequisites">Prerequisites</h3>
<p>Running on a Linux environment, ensure that Docker,
Docker Compose and <a href="https://git-scm.com/">Git</a>, 
are installed and running on your system.
These tools are necessary to set up the QGIS development environment using Docker.
Make sure to install the latest version of Docker Compose by following installation instructions from 
<a href="https://docs.docker.com/compose/install/linux">here</a>.</p>

<h3 id="1-clone-qgis-repository">1. Clone QGIS repository</h3>
<p>Clone the QGIS repository from GitHub to get the source code for building QGIS. 
This will provide you with the latest source code to configure and compile the application. 
QGIS official repository can be accessed from <a href="https://github.com/qgis/QGIS">here</a>. Users can select
what version to work on by checking out the corresponding QGIS version git tag.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone git@github.com:qgis/QGIS.git
</code></pre></div></div>

<p>After cloning is complete, you can switch to any QGIS released version branch or stay with the master.</p>

<p>I recommend to select a released version branch or a final release tag and check it out because the included changes in the 
release branches tend to be more stable compared to the master branch changes.</p>

<p>See all QGIS repository branches <a href="https://github.com/qgis/QGIS/branches">here</a>.</p>

<h3 id="2-create-docker-compose-configuration">2. Create Docker compose configuration</h3>
<p>After cloning the repository, change directory and get inside the QGIS root folder</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nb">cd </span>QGIS
</code></pre></div></div>
<p>Create a <code class="language-plaintext highlighter-rouge">docker-compose.yml</code> file that defines the necessary services and environment. 
The file will include settings for the QGIS build dependencies and X11 forwarding for GUI applications.</p>

<p>The <code class="language-plaintext highlighter-rouge">docker-compose.yml</code> file should contain the below structure and content. This file should
be located in the root of the QGIS directory.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>services:
  qgis-dev-live:
    image: qgis/qgis3-build-deps-22.04-qt5:latest
    volumes:
      - ..:/src/QGIS
      - build:/src/QGIS/build
    environment:
      - <span class="nv">DISPLAY</span><span class="o">=</span><span class="k">${</span><span class="nv">DISPLAY</span><span class="k">}</span>
      - <span class="nv">XAUTHORITY</span><span class="o">=</span><span class="k">${</span><span class="nv">XAUTHORITY</span><span class="k">}</span>
      - <span class="nv">XDG_RUNTIME_DIR</span><span class="o">=</span>/tmp
    network_mode: host
    working_dir: /src/QGIS/build
    <span class="nb">command</span>: <span class="nb">tail</span> <span class="nt">-f</span> /dev/null

volumes:
  build:
</code></pre></div></div>

<p>Where <code class="language-plaintext highlighter-rouge">qgis/qgis3-build-deps-22.04-qt5:latest</code> is the image responsible for all the QGIS development dependencies and
recommended for use, other images can be fetched from here https://hub.docker.com/u/qgis?page=1&amp;search=build-deps.</p>

<p>The <code class="language-plaintext highlighter-rouge">volumes</code> part contain information of where to mount and link the QGIS source and the build directory, while the <code class="language-plaintext highlighter-rouge">environment</code>
section defines all the necessary variable required to enable display configuration between the host and the Docker containers.</p>

<h3 id="3-build-the-docker-environment">3. Build the Docker environment</h3>
<p>Use Docker Compose to build the development environment based on the <code class="language-plaintext highlighter-rouge">docker-compose.yml</code> configuration.
This will download the necessary Docker image with all build dependencies and set up the environment for compiling QGIS.</p>

<p>In this step we assume all the Docker tools have already been installed in the system, if not see
this <a href="https://www.docker.com/get-started/">page</a> on how to install the essential Docker tools.</p>

<p>Use the following commands to run the build and start the Docker container.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker compose build qgis-dev-live
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker compose up 
</code></pre></div></div>

<p>If the above commands are successful, the following content will be displayed in the terminal.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>+] Running 1/1
 ✔ Container qgis-qgis-dev-live-1  Started 

</code></pre></div></div>

<h3 id="4-start-the-development-environment">4. Start the development environment</h3>
<p>Configuring and build the QGIS source can be done by passing build commands directly
in Docker exec command or via an interactive bash shell.</p>

<p>For the latter option, in order launch the Docker container with an interactive bash shell to begin development. 
Use the below command, this will provide you with a command-line interface inside the container 
to manage the build process.</p>

<p>Command to start interactive bash shell</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker compose <span class="nb">exec</span> <span class="nt">-it</span> qgis-dev-live bash

</code></pre></div></div>

<h3 id="5-configure-and-build-qgis">5. Configure and build QGIS</h3>
<p>Run CMake and Ninja commands inside the container to configure and compile QGIS. 
This will build QGIS from source with specific configuration options like enabling plugins and
<a href="https://grass.osgeo.org/">GRASS</a> integration.</p>

<p>At the time of writing this post the used QGIS docker image had one issue in linking the QScintilla2 library.
The following commands makes sure that the library symlinks are created in the folder that QGIS expects them to be.</p>

<p><strong>Note:</strong> This should not be the usual way of doing this, once the upstream image is fixed this step will not be needed anymore.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker compose run qgis-dev-live bash <span class="nt">-c</span> <span class="s2">"</span><span class="se">\</span><span class="s2">
  mkdir -p /usr/lib/x86_64-linux-gnu &amp;&amp; </span><span class="se">\</span><span class="s2">
  echo 'Checking for QScintilla2 libraries...' &amp;&amp; </span><span class="se">\</span><span class="s2">
  if [ -f /usr/lib/libqscintilla2_qt5.so ]; then </span><span class="se">\</span><span class="s2">
    echo 'Found QScintilla2 libraries in /usr/lib - creating symlinks...' &amp;&amp; </span><span class="se">\</span><span class="s2">
    ln -sf /usr/lib/libqscintilla2_qt5.so /usr/lib/x86_64-linux-gnu/libqscintilla2_qt5.so &amp;&amp; </span><span class="se">\</span><span class="s2">
    [ -f /usr/lib/libqscintilla2_qt5.so.15 ] &amp;&amp; ln -sf /usr/lib/libqscintilla2_qt5.so.15 /usr/lib/x86_64-linux-gnu/libqscintilla2_qt5.so.15 &amp;&amp; </span><span class="se">\</span><span class="s2">
    [ -f /usr/lib/libqscintilla2_qt5.so.15.0 ] &amp;&amp; ln -sf /usr/lib/libqscintilla2_qt5.so.15.0 /usr/lib/x86_64-linux-gnu/libqscintilla2_qt5.so.15.0 &amp;&amp; </span><span class="se">\</span><span class="s2">
    [ -f /usr/lib/libqscintilla2_qt5.so.15.0.0 ] &amp;&amp; ln -sf /usr/lib/libqscintilla2_qt5.so.15.0.0 /usr/lib/x86_64-linux-gnu/libqscintilla2_qt5.so.15.0.0 &amp;&amp; </span><span class="se">\</span><span class="s2">
    echo 'Created QScintilla2 symlinks' &amp;&amp; </span><span class="se">\</span><span class="s2">
    ls -la /usr/lib/x86_64-linux-gnu/libqscintilla2_qt5.so*; </span><span class="se">\</span><span class="s2">
  else </span><span class="se">\</span><span class="s2">
    echo 'QScintilla2 libraries not found in /usr/lib' &amp;&amp; </span><span class="se">\</span><span class="s2">
    echo 'Checking existing libraries in /usr/lib/x86_64-linux-gnu...' &amp;&amp; </span><span class="se">\</span><span class="s2">
    ls -la /usr/lib/x86_64-linux-gnu/libqscintilla2_qt5.so* || echo 'No QScintilla2 libraries found'; </span><span class="se">\</span><span class="s2">
  fi
"</span>
</code></pre></div></div>

<p>After fixing the library symlinks, we will now head over to the main part of the QGIS compilation.
In this step we will configure, build and install QGIS using <a href="https://cmake.org/">CMake</a>(a meta build tool) and
<a href="https://github.com/ninja-build/ninja">Ninja</a> (build tool).</p>

<p>The commands also mark the Git directory as safe globally, in order to avoid trust warnings when using
Git in the build.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  docker compose run qgis-dev-live bash <span class="nt">-c</span> <span class="s2">"</span><span class="se">\</span><span class="s2">
    echo '[</span><span class="si">$(</span><span class="nb">date</span><span class="si">)</span><span class="s2">] Starting CMake configuration...' &amp;&amp; </span><span class="se">\</span><span class="s2">
    cmake ../QGIS -GNinja </span><span class="se">\</span><span class="s2">
        -DWITH_STAGED_PLUGINS=ON </span><span class="se">\</span><span class="s2">
        -DCMAKE_INSTALL_PREFIX=/usr </span><span class="se">\</span><span class="s2">
        -DWITH_GRASS=ON </span><span class="se">\</span><span class="s2">
        -DSUPPRESS_QT_WARNINGS=ON </span><span class="se">\</span><span class="s2">
        -DENABLE_TESTS=OFF </span><span class="se">\</span><span class="s2">
        -DWITH_QSPATIALITE=ON </span><span class="se">\</span><span class="s2">
        -DWITH_QWTPOLAR=OFF </span><span class="se">\</span><span class="s2">
        -DWITH_APIDOC=OFF </span><span class="se">\</span><span class="s2">
        -DWITH_ASTYLE=OFF </span><span class="se">\</span><span class="s2">
        -DWITH_DESKTOP=ON </span><span class="se">\</span><span class="s2">
        -DWITH_BINDINGS=ON </span><span class="se">\</span><span class="s2">
        -DDISABLE_DEPRECATED=ON &amp;&amp; </span><span class="se">\</span><span class="s2">
    echo '[</span><span class="si">$(</span><span class="nb">date</span><span class="si">)</span><span class="s2">] CMake configuration completed.' &amp;&amp; </span><span class="se">\</span><span class="s2">
    git config --global --add safe.directory /src/QGIS/QGIS &amp;&amp; </span><span class="se">\</span><span class="s2">
    echo '[</span><span class="si">$(</span><span class="nb">date</span><span class="si">)</span><span class="s2">] Starting QGIS build...' &amp;&amp; </span><span class="se">\</span><span class="s2">
    VERBOSE=1 ninja -v &amp;&amp; </span><span class="se">\</span><span class="s2">
    echo '[</span><span class="si">$(</span><span class="nb">date</span><span class="si">)</span><span class="s2">] QGIS build completed.' &amp;&amp; </span><span class="se">\</span><span class="s2">
    echo '[</span><span class="si">$(</span><span class="nb">date</span><span class="si">)</span><span class="s2">] Starting QGIS installation...' &amp;&amp; </span><span class="se">\</span><span class="s2">
    VERBOSE=1 ninja -v install &amp;&amp; </span><span class="se">\</span><span class="s2">
    echo '[</span><span class="si">$(</span><span class="nb">date</span><span class="si">)</span><span class="s2">] Installation completed.'"</span>
    

</code></pre></div></div>
<p>The passed CMake build flags and their meaning.</p>

<div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">-GNinja</span><span class="pi">:</span> <span class="s">Use Ninja as the build system..</span>
<span class="na">-DWITH_STAGED_PLUGINS=ON</span><span class="pi">:</span> <span class="s">Enable staged QGIS plugins(plugins that comes with QGIS).</span>
<span class="na">-DCMAKE_INSTALL_PREFIX=/usr</span><span class="pi">:</span> <span class="s">Set installation path to /usr.</span>
<span class="na">-DWITH_GRASS=ON</span><span class="pi">:</span> <span class="s">Enable GRASS GIS integration.</span>
<span class="na">-DSUPPRESS_QT_WARNINGS=ON</span><span class="pi">:</span> <span class="s">Hide Qt deprecation warnings.</span>
<span class="na">-DENABLE_TESTS=OFF</span><span class="pi">:</span> <span class="s">Skip building test code.</span>
<span class="na">-DWITH_QSPATIALITE=ON</span><span class="pi">:</span> <span class="s">Enable support for SpatiaLite.</span>
<span class="na">-DWITH_QWTPOLAR=OFF</span><span class="pi">:</span> <span class="s">Disable QwtPolar support (not needed).</span>
<span class="na">-DWITH_APIDOC=OFF</span><span class="pi">:</span> <span class="s">Disable API documentation generation.</span>
<span class="na">-DWITH_ASTYLE=OFF</span><span class="pi">:</span> <span class="s">Skip AStyle code formatting check.</span>
<span class="na">-DWITH_DESKTOP=ON</span><span class="pi">:</span> <span class="s">Build the desktop QGIS application.</span>
<span class="na">-DWITH_BINDINGS=ON</span><span class="pi">:</span> <span class="s">Build Python bindings.</span>
<span class="na">-DDISABLE_DEPRECATED=ON</span><span class="pi">:</span> <span class="s">Disable deprecated code in the build.</span>
</code></pre></div></div>

<p>Some of these flags can be removed or turned off if you want to boost the compile time or
if you don’t want certain features in the final compiled QGIS. Checkout more configuration
flags <a href="https://github.com/qgis/QGIS/blob/master/INSTALL.md#371-available-compilation-flags">here</a>.</p>

<p>Overall the above series of commands can take a while to finish depending on how powerful the used PC, 
after the build is done, installation process using Ninja shouldn’t take too long.</p>

<h3 id="6-run-qgis-from-the-build">6. Run QGIS from the build</h3>
<p>After the build is successfully, run the compiled QGIS application from the container to verify 
the installation and open the compiled QGIS application.</p>

<p>Use the xhost command to allow the Docker container to control access to the X11 display
and enabling using the built QGIS binary <code class="language-plaintext highlighter-rouge">qgis</code> from inside the container to launch the application.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>xhost +local:docker
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker compose run qgis-dev-live bash <span class="nt">-c</span> <span class="s2">"./output/bin/qgis"</span>
</code></pre></div></div>

<p>After running the above commands, hopefully the QGIS desktop application should start!</p>

<h3 id="notes-and-troubleshooting">Notes and troubleshooting</h3>
<p>Be aware that the build process may take significant time depending on your system’s resources. 
If you encounter issues, check your X11 configuration and Docker permissions for potential fixes.</p>

<p>There is a <a href="https://github.com/Samweli/qgis_gis_day_tz/blob/master/materials/linux/qgis_build_linux.ipynb">Jupyter notebook</a> 
that contains all the commands involved in compiling and running QGIS source, the notebook was part of materials used
in the 2024 GIS Day hacking in Tanzania. Feel free to use it if you don’t want to run commands in terminal.</p>

<h2 id="more-benefits">More benefits</h2>

<p>Overall the availability of the QGIS Docker images brings other several compelling use cases apart for simplifying the development, 
here are some examples:</p>

<h4 id="running-unreleased-versions">Running unreleased versions</h4>
<p>Docker images allow you to easily run nightly builds or versions from the master branch of QGIS.
This is especially useful for testing new features or bug fixes that have not yet been officially released 
or for running QGIS in a server environment without a GUI.</p>

<h4 id="legacy-qgis-versions">Legacy QGIS versions</h4>
<p>If you need to support older versions of QGIS in an operating system that only allows the latest versions,
Docker can help by creating isolated environments where specific versions of QGIS can run independently of
the system’s package manager.</p>

<h2 id="contributing-to-qgis">Contributing to QGIS</h2>

<p>Contributing to the QGIS is a great way to support the open-source community and improve one of the important GIS tools used
in the world.</p>

<p>The QGIS team welcomes any contribution from anywhere. QGIS itself is a team work consisting of different people from all 
over the world, any addition, edit or improvement in the code, documentation or any other QGIS project part would be 
heavily appreciated.</p>

<p>Before starting contributing to the QGIS source here are some of important things go over first:</p>

<ul>
  <li>Familiarize with C++ and <a href="https://www.qt.io/product/framework">Qt framework</a>;</li>
  <li>Review the QGIS coding standards; This will help in making sure reviewers can provide right feedback and 
the suggested changes are easily reviewable.</li>
  <li>Create or find issue related to the problem; Tracking discussions will provide context for the target contribution.</li>
  <li>Run tests locally; It won’t look good if reviewers find minor bugs when reviewing new changes. Always make sure to catch regressions and 
new changes bugs that can be detected early by running unit tests.</li>
  <li>Documentation on new changes; The code, commit and changes details should be descriptive enough to provide enough information about the 
proposed work.</li>
</ul>

<p>Finally, don’t stress out, go ahead and make the pull request! Contributions don’t have to be perfect and reviewers are 
always there to improve the new changes.</p>

<p>For the full guide on QGIS development see the developers guideline found <a href="https://docs.qgis.org/3.40/en/docs/developers_guide">here</a>.</p>

<h2 id="reach-out">Reach out</h2>

<p>If you have questions about using Docker for QGIS development or general questions about contributing to QGIS,
there are several places where you can get help:</p>

<ul>
  <li><strong>QGIS Developer Mailing List</strong>: The <a href="https://lists.osgeo.org/mailman/listinfo/qgis-developer">QGIS Developer Mailing List</a>
is a great place to ask questions and discuss development-related topics.</li>
  <li><strong>QGIS GitHub Repository</strong>: The <a href="https://github.com/qgis/qgis">QGIS GitHub</a> is where all the development happens,
and you can submit issues, pull requests, and more.</li>
</ul>

<h2 id="final-thoughts">Final thoughts</h2>

<p>Using Docker to set up a QGIS development environment simplifies the process, especially for newcomers
who may struggle with the dependency management required for compiling QGIS from source. 
With Docker, you can create a consistent, reproducible environment for QGIS development 
that works across platforms and makes contributing to the QGIS project easier than ever.</p>

<p>Stay tuned — next, I’ll be sharing how to set up your daily development workflow,
including recompiling QGIS after making new changes while using Docker, debugging and testing locally!</p>]]></content><author><name>Samweli Mwakisambwe</name><email>smwltwesa6@gmail.com</email></author><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Visualizing Dar es salaam City Drone Imagery</title><link href="http://0.0.0.0:4000/Drone-Imagery-Viz/" rel="alternate" type="text/html" title="Visualizing Dar es salaam City Drone Imagery" /><published>2019-09-03T00:00:00+00:00</published><updated>2019-09-03T00:00:00+00:00</updated><id>http://0.0.0.0:4000/-Drone-Imagery-Viz</id><content type="html" xml:base="http://0.0.0.0:4000/Drone-Imagery-Viz/"><![CDATA[![](https://raw.githubusercontent.com/samweli/jekyll-now/master/images/dar-drone-imagery-viz.png)

_Drone Imagery Map_

## Visualizing Dar es salaam drone imagery

At the end of 2017, The World Bank Tanzania, in collaboration with the Dar Rapid Transit ([DART](https://www.dart.go.tz/)) Agency, 
supported the collection of high-resolution drone imagery across Dar es Salaam. This initiative was part of a broader effort to 
support urban planning and development along the proposed Bus Rapid Transit (BRT) routes throughout the city.

The drone mapping activity successfully captured detailed imagery of all areas surrounding the planned BRT corridors. 
This rich dataset was expected to serve as a critical resource for planning and decision-making throughout
the BRT development process.

However, once the data was collected, the next challenge emerged—visualizing and accessing it effectively. 
The raw drone imagery, provided in GeoTIFF format, was extremely large in size. This made it difficult to load 
and interact with the data on a regular computer. Standard desktop machines often struggled to open the files, 
and even when they did, rendering the imagery was slow.

To make things more complicated, viewing GeoTIFFs typically requires specialized Geographic Information System (GIS) software,
which is often desktop-based and not very user-friendly for non-technical users. This meant that anyone wanting to interact 
with the data had to first install special GIS tools, creating a barrier for planners and the public alike.

These limitations highlighted the need for a more accessible, web-based solution—something that didn’t require 
powerful hardware or dedicated software installation, and could be used directly from a browser.

As a member of The World Bank Tanzania team supporting the DART project, 
I was tasked with developing a visualization tool for this imagery dataset. 
My goal was to make the drone imagery easily accessible to a wide range of users, 
from urban planners to city officials and community members.

Using [Mapbox GL](https://docs.mapbox.com/mapbox-gl-js/overview/) I built a lightweight, high-performance web application that could display the
large drone imagery efficiently, directly within a browser window.

The result was a high perfomance and easily accessible web map, it can be viewed [here](http://brt-viz.herokuapp.com/)]]></content><author><name>Samweli Mwakisambwe</name><email>smwltwesa6@gmail.com</email></author><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Converting ODK location data to WKT in QGIS</title><link href="http://0.0.0.0:4000/ODKTrace2WKT/" rel="alternate" type="text/html" title="Converting ODK location data to WKT in QGIS" /><published>2019-09-01T00:00:00+00:00</published><updated>2019-09-01T00:00:00+00:00</updated><id>http://0.0.0.0:4000/-ODKTrace2WKT</id><content type="html" xml:base="http://0.0.0.0:4000/ODKTrace2WKT/"><![CDATA[![](https://raw.githubusercontent.com/samweli/jekyll-now/master/images/odktrace2wkt.png)

_Plugin interface_

## Loading ODK location data in QGIS

[Open Data Kit(ODK)](https://getodk.org/) is now widely used in collecting location data. One notable use case is the project 
called [Ramani Huria](https://ramanihuria.org/) (Open Map) which used ODK to map Dar es salaam city drains. 
One of the challenges in using ODK to collect linestring data is the format that it 
save the data into (geotrace), the format currently is not a standard that is directly supported in most GIS applications.

While ODK supports collecting point and line-based geographic data, the format it uses to store data is not
a widely accepted. 
This has made it difficult for teams to import and work with the data in tools like QGIS after data collection.

Ramani Huria team was faced with this problem and they wrote script that convert the data from geotrace 
to Well-Known text format which is widely used standard. 

The issue with scripts is they are not very user friendly. Recognizing the need for a more accessible solution, 
the Ramani Huria team tasked me with creating a QGIS plugin to simplify this conversion process for everyday users.

I developed a QGIS plugin that helps users to convert the ODK geotrace data into Well-Known text format by building upon the work that Ramani Huria had already started. 
Since the team already had a [script](https://github.com/ivangayton/ODK_geotrace_to_WKT/blob/master/lines_to_wkt.py) written in Python.

The plugin works on all QGIS 3 versions. See the following [how to use video](https://www.youtube.com/watch?v=GvxkoVP0-Dc) on plugin usage instructions.

The plugin is intended to make geospatial data workflows smoother and more accessible, particularly for 
community mapping teams and organizations using ODK in the field. By bridging the gap between mobile data collection 
and GIS analysis, it enables more people to benefit from the power of open mapping tools.

[Plugin repository](https://plugins.qgis.org/plugins/odktrace2wkt/)

[Source code](https://github.com/Samweli/odktrace2wkt)]]></content><author><name>Samweli Mwakisambwe</name><email>smwltwesa6@gmail.com</email></author><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Using AI in Trash Detection</title><link href="http://0.0.0.0:4000/AI-Trash-Detection/" rel="alternate" type="text/html" title="Using AI in Trash Detection" /><published>2019-08-25T00:00:00+00:00</published><updated>2019-08-25T00:00:00+00:00</updated><id>http://0.0.0.0:4000/AI-Trash-Detection</id><content type="html" xml:base="http://0.0.0.0:4000/AI-Trash-Detection/"><![CDATA[![](https://raw.githubusercontent.com/samweli/jekyll-now/master/images/trash-detector.png)

_Trash detection web application interface_

## Trash detection from mapping images

During the trash mapping activity [here](http://samweli.github.io/Trash-Map/), some of the collected trash images didn't 
contain waste. This was mostly because certain photos were taken at legal dump sites,
which weren’t clearly marked during data collection.

One of the main issues was that the data collection process didn’t include any form 
of tagging to specify whether an image contained waste, whether it was a legal or illegal dumping site,
or if there was any visible trash at all. This lack of metadata posed a challenge for filtering 
and interpreting the dataset effectively.

To solve this, I decided to build a simple web application that can automatically
detect whether an image contains trash. The purpose of this tool is to assist in 
post-processing the mapping data by tagging images based on the presence or absence of visible waste.
This step helps to clean up the dataset and make it more useful for further analysis, decision-making,
or public awareness campaigns.


The result application can be found [here](http://trash-detection.herokuapp.com/).

Once the tool was ready, I ran it on the full set of collected images. The results were visualized through an interactive [web app](http://dar-trash-viz.netlify.app). You can explore these insights by navigating to the
`Analysis` menu and selecting the `Trash Tagging` option. This section provides a breakdown of how many images 
were flagged as containing waste versus those that weren’t, as well as other related statistics.


In terms of performance, the tool achieved a rough accuracy of about 60%, meaning that 6 out of every 10 images were correctly tagged in
terms of trash presence. While this is far from perfect, it's a useful first step toward automating the cleanup and classification of 
large image datasets gathered in the field.

Going forward, I plan to improve the [tool](https://github.com/ResilientDar/trash-detector)’s accuracy and possibly incorporate manual review options or allow users to
contribute to labeling images. This could help create a more reliable and scalable system for waste detection in mapping projects.

If you're interested in contributing, testing the tool, or sharing feedback, feel free to get in touch!]]></content><author><name>Samweli Mwakisambwe</name><email>smwltwesa6@gmail.com</email></author><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">The Making of Trash Data Visualization</title><link href="http://0.0.0.0:4000/Trash-Map/" rel="alternate" type="text/html" title="The Making of Trash Data Visualization" /><published>2018-09-29T00:00:00+00:00</published><updated>2018-09-29T00:00:00+00:00</updated><id>http://0.0.0.0:4000/Trash-Map</id><content type="html" xml:base="http://0.0.0.0:4000/Trash-Map/"><![CDATA[![](https://raw.githubusercontent.com/samweli/jekyll-now/master/images/trash_map.png)

_Online Trash Map_

In August 2018 [HOT](https://www.hotosm.org) together with [Nipe Fagio](http://nipefagio.co.tz) organized waste data collection activity, allocating more than 
100 students/mappers to locate and collect information about the types of piles in the Dar es salaam City.

The aim of this activity was to raise awareness to the responsible institutions for waste management about the importance 
of data-driven decision and policy making and also to showcase how waste data can be used to measure and evaluate the 
waste collection problem in Dar es salaam.

The activity resulted into collection of more than 10,000 waste piles. After the activity the HOT team presented the 
data to  [TURP](https://www.worldbank.org/en/programs/tanzania-urban-resilience-program) program.

As part of TURP team, we analyzed the data and built a web map that visualized and provide important insights for the 
nearly 10,000 points. We used [Mapbox GL JS](https://docs.mapbox.com/mapbox-gl-js/api/) together with a [React](https://reactjs.org/) framework, these enabled creating a 
vector based web map that has high rendering performance and a smooth user interaction.

The trash web map can be accessed [here](http://dar-trash-viz.netlify.app) and source code for the map [here](https://github.com/ResilientDar/dar-trash-viz/).

## Insights

The web map serves as an example of how spatial data and geospatial technologies can be leveraged to bridge the 
gap between available waste-related data and effective policymaking. The current waste management challenges in Dar es Salaam
pose a significant obstacle to the city’s aspirations for urban development. Ensuring the availability and accessibility of 
reliable waste data is a crucial first step toward addressing this issue.

By enabling data analysis, such tools offer the ability to conduct informed and calculated assessments of main problems, 
thereby supporting evidence-based decision-making. One particular insight from the map is the 
high concentration of waste disposal sites in and around the city center—areas characterized by dense population,
increased human activity, and vibrant local economies.

Such insights can reveal underlying behavioral patterns related to waste disposal. Once identified and analyzed,
these patterns can inform solutions that are grounded in actual data, thereby increasing the likelihood of resolving
the main challenges.

Moreover, the web-based map infographics indicate that many of these waste accumulation points are accessible 
by vehicles or carts, suggesting that targeted cleaning and maintenance activities are feasible. 
This accessibility further supports the potential for sustained cleanliness and improved waste management 
in these areas.


## Future

Addressing waste collection challenges in Dar es Salaam through data-driven approaches, it is essential
to incorporate a broader range of metrics and analyses. The city must recognize and integrate economic, environmental,
and social indicators to develop comprehensive and sustainable waste management solutions. This multi-dimensional 
perspective is key to achieving a cleaner and more livable Dar es Salaam and other developing countries cities with
similar challenges.

The trash map aims to inspire other partners and stakeholders to support and invest in data-centric waste management 
technologies. Tools like these play a critical role in highlighting the severity of the current waste problem and 
can drive informed actions toward meaningful change.]]></content><author><name>Samweli Mwakisambwe</name><email>smwltwesa6@gmail.com</email></author><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Developing Twaamtaro (Adopt a Drain)</title><link href="http://0.0.0.0:4000/Twaamtaro/" rel="alternate" type="text/html" title="Developing Twaamtaro (Adopt a Drain)" /><published>2017-01-30T00:00:00+00:00</published><updated>2017-01-30T00:00:00+00:00</updated><id>http://0.0.0.0:4000/Twaamtaro</id><content type="html" xml:base="http://0.0.0.0:4000/Twaamtaro/"><![CDATA[![](https://raw.githubusercontent.com/samweli/jekyll-now/master/images/twaamtaro_logo.png)

## Twaamtaro Tanzania

Online platform that tracks local drain cleanliness & information on solid waste deposits.
Inspired by Adopt a Drain from Code for America!.

### Background
Waste cleanness in Dar es salaam drains is rarely done, and when it is done, there is lack of dissemination of the work and drains status to respective leaders and stakeholders. There is always a need to raise community engagement in drains cleaning and to find innovative ways that can enable provision of reports on drains cleaness to the community.

### Leverage

Community mapping project ‘ramani huria’ has collected the available data on the drainage network. These are available and  can be  found on openstreetmap, these data shows that the network has not covered the large part of the city and from different reports it is not frequently maintained in the areas it has covered. More details can be found [here](http://ramanihuria.org/mapping-drainage-in-dar-es-salaam/)

Building on this work, arrangements were made to organize the community to frequently clean these drains so as to help water flow especially on flood prone areas, this went in parallel with development of application to monitor, store and show drains information called Twaa mtaro (Adopt a drain).

Twaamtaro as a platform enables the community to report about cleaness activities that are done on drains, it does this by letting users send drains information through SMS, USSD and WEB, this enables even the average citizen who does not have access to the Internet to be able to use the platform.

The workflow is citizen are assigned drains by the street leaders, they receive SMS notification from the platform, when the finish cleaning they can send SMS or use USSD or login into the online twaamtaro site and update the status of their drains.


![Twaamtaro in action](https://raw.githubusercontent.com/samweli/jekyll-now/master/images/twaamtaro_in_action.png)

_Twaamtaro in action_

![Me presenting Twaamtaro to World Bank Tanzania Staffs](https://raw.githubusercontent.com/samweli/jekyll-now/master/images/twaamtaro_pres.jpg)

_Samweli (Team lead) presenting Twaamtaro to World Bank Tanzania Staffs_

[Source code](https://github.com/Samweli/twaamtaro)

[Platform](https://twaamtaro.org)]]></content><author><name>Samweli Mwakisambwe</name><email>smwltwesa6@gmail.com</email></author><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Isochrone Maps Creation in QGIS</title><link href="http://0.0.0.0:4000/Isochrone-Maps/" rel="alternate" type="text/html" title="Isochrone Maps Creation in QGIS" /><published>2016-09-22T00:00:00+00:00</published><updated>2016-09-22T00:00:00+00:00</updated><id>http://0.0.0.0:4000/Isochrone-Maps</id><content type="html" xml:base="http://0.0.0.0:4000/Isochrone-Maps/"><![CDATA[![](https://raw.githubusercontent.com/samweli/jekyll-now/master/images/isochrone_map.png)

_example isochrone map showing hospitals accessibility times in minutes by car_

## Isochrone Map

Isochrone maps are a powerful way to visualize accessibility and movement within geographic areas.
Unlike traditional maps that focus on distances, isochrone maps illustrate the areas that can be reached 
from a specific location within a given amount of time—whether by walking, driving, cycling, or public transportation. 
These maps are particularly useful in urban planning, emergency response, transportation analysis 
and public service delivery.

For example, a city planner might use an isochrone map to evaluate how many residents can reach a health facility within
30 minutes by foot or to identify underserved neighborhoods based on commute times to the nearest school.

At the time of writing this post, there were limited options available for creating isochrone maps using open-source tools.
Most services that offered isochrone generation were either commercial, limited in functionality, 
or required API keys with usage restrictions. Additionally, QGIS( a free desktop GIS application) did not natively support
the generation of isochrones, which presented a barrier for many users interested in spatial accessibility analysis
without relying on proprietary software or paid APIs.

Recognizing this gap, I created a QGIS plugin to enable users to generate isochrone maps 
directly within the QGIS environment. This plugin extends the functionality of QGIS by allowing users to easily define
origin points, provide travel networks, and generate accessibility zones using open routing services. It simplifies a process
that previously required external tools or manual steps, making it far more accessible to planners, researchers, and civic
technologists who rely on free and open-source GIS software.

One of the core goals in developing the tool was to make it completely open source, so that it could be freely used, 
adapted, and extended by the broader GIS and open data community. The plugin is hosted publicly and available for download,
with full documentation and source code accessible [here](https://github.com/Samweli/isochrones).

Since its release, the plugin has received a strong reception within the QGIS community. As of August 2019, 
it had been downloaded over **7,000** times from the official [QGIS plugin repository](https://plugins.qgis.org/plugins/isochrones/#plugin-versions),
highlighting the demand for accessible isochrone tools within the open-source GIS ecosystem. 
These numbers continue to grow as more users discover its capabilities.

The plugin is a contribution to the broader mission of opening access to geospatial analysis tools. 
By lowering the barrier to entry for isochrone mapping, it empowers individuals and institutions especially 
in resource-constrained settings to better understand, enable data based decision-making and 
improve accessibility in their environments.

### Links

[Plugin repository](https://plugins.qgis.org/plugins/isochrones/)

[Source code](https://github.com/Samweli/isochrones)]]></content><author><name>Samweli Mwakisambwe</name><email>smwltwesa6@gmail.com</email></author><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Developing Flood Maps</title><link href="http://0.0.0.0:4000/Flood-Maps/" rel="alternate" type="text/html" title="Developing Flood Maps" /><published>2016-07-22T00:00:00+00:00</published><updated>2016-07-22T00:00:00+00:00</updated><id>http://0.0.0.0:4000/Flood-Maps</id><content type="html" xml:base="http://0.0.0.0:4000/Flood-Maps/"><![CDATA[![](https://raw.githubusercontent.com/samweli/jekyll-now/master/images/flood_map.png)

## Floods in Dar es salaam

Dar es salaam is one of the fastest growing cities in Africa, it has a 5 million population and 5.6% percent 
growth rate per year, it is also the most important economic center in Tanzania. This indicates
that the city should undertake all social and economical preparations effectively accommodate population growth.
	
However, for the past years the city has been overwhelmed by the growth rate of the population leading to inadequate 
public services provision, unequal resources sharing such as water, electricity and a dormant urban infrastructure. 
The latter being the major cause for the recurring floods in the city.

As the city continues to expand, much of the new development has occurred informally and without adequate planning.
This unstructured urban sprawl has placed huge strain on the road network and drainage systems, making mobility
increasingly difficult. During the rainy season, poorly planned settlements—often built in flood-prone areas, makes
the situation more difficult by blocking natural water channels, further contributing to the severity and frequency of
urban flooding.


### Floods Map Tool

In relation to the flood problem in Dar es salaam, I made an effort to help the society in reporting of the 
floods events, believing this will enable measuring floods impact and foster robust response during raining seasons.

An online flood map, Inspired by [flood map india](https://osm-in.github.io/flood-map/), a tool
that shows flooded features in realtime as reported by map users, this is crowdsourced based effort to map 
inundated features in Dar es salaam.

In response to the flooding challenges in Dar es Salaam, I took the initiative to support the community by 
developing a tool aimed at improving the reporting of flood events. I believe that by enabling timely and accessible 
flood reporting, it will make it possible to better assess the impact of flooding and support more coordinated and effective
responses during the rainy seasons. Collecting such data from those directly affected offers crucial insights into the 
severity and spread of floods, helping both authorities and communities prepare and respond more efficiently.

To bring this vision to life, I developed an online flood mapping platform, inspired by the [flood map india](https://osm-in.github.io/flood-map/) project. 
The tool allows users to contribute real-time updates about flooded areas using a crowdsourced approach. 

Similarly, the Dar es Salaam version of the map empowers residents to report inundated roads, neighborhoods, and key 
infrastructure in real time. By relying on contributions from the public, the platform builds a dynamic, community-driven 
picture of flood conditions across the city.

This tool serves as both a public awareness and a practical response aid. It helps identify flood hotspots 
as they occur, enabling faster decision-making for rerouting traffic, allocating emergency resources, or issuing alerts.
Over time, this kind of community mapping can also support long-term urban planning by highlighting areas that require 
drainage improvements or other interventions.

The flood map is a step toward participatory resilience building. 
By involving citizens directly in disaster response, it strengthens the relationship between the public, 
urban planners, and emergency services, paving the way for a more informed and resilient Dar es Salaam.

[Link to the Flood map](http://samweli.github.io/flood-map/)]]></content><author><name>Samweli Mwakisambwe</name><email>smwltwesa6@gmail.com</email></author><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Code for Resilience</title><link href="http://0.0.0.0:4000/Code-for-Resilience/" rel="alternate" type="text/html" title="Code for Resilience" /><published>2016-05-30T00:00:00+00:00</published><updated>2016-05-30T00:00:00+00:00</updated><id>http://0.0.0.0:4000/Code-for-Resilience</id><content type="html" xml:base="http://0.0.0.0:4000/Code-for-Resilience/"><![CDATA[![Code for Resilience Dar es salaam kickoff](https://raw.githubusercontent.com/samweli/jekyll-now/master/images/code-for-resilience.png)

## Code for Resilience Dar es salaam

Dar es Salaam and Stone Town are the two primary cities of Mainland Tanzania and Zanzibar
with populations of 5.5 million and 150,000 respectively. Each of these cities and their country
have unique challenges and natural hazards. Dar es Salaam for instance is challenged by bi-annual flooding,
impacting many thousands of its citizens every year. In response to this, the World Bank, GFDRR, 
Humanitarian OpenStreetMap Team and the Red Cross are supporting the Tanzanian Commission of Science and Technology,
Buni Innovation Hub, Dar es Salaam City Council, Ardhi University and the University of Dar es Salaam
with a community mapping for flood resilience project, Ramani Huria. 

In coordinating all of these actors, Ramani Huria has leveraged the skills of over 100 community members,
150 students, collecting data in the most flood prone neighbourhoods of Dar es Salaam, making maps and
underlying data freely available for Dar es Salaam.

In 2015, Ramani Huria, in collaboration with the World Bank, had the opportunity to host the [Code for Resilience](https://understandrisk.org/initiative/code-for-resilience/#:~:text=Code%20for%20Resilience%20(CfR)%20fosters,risks%20posed%20by%20natural%20disasters.) 
program in Dar es Salaam, Tanzania. This initiative aims at bringing together local talent, international expertise, and
community knowledge under one roof with a shared goal: to develop innovative tools that address the real challenges
posed by natural disasters in a specified region.

As part of the World Bank team, I supervised the Code for Resilience fellows and mentored them. 
Each of the fellows was assigned a problem statement (project) from which they had to design and implement a solution. 

Each of these projects and others were initiated on January 30th 2015, via a collaborative event at the Buni Innovation Hub in Tanzania, 
the event brought together Code for Resilience Fellows from the University of Dar es Salaam, 
experts from the Dar es Salaam City Council, and local developers. 
This initiative aimed to develop tools that enhance disaster preparedness and community resilience. 
Among the projects initiated were the automation of population statistics delivery and the creation of 3D-printed 
weather stations using recycled plastic, reflecting a commitment to sustainable and accessible technological solutions.

One significant project from this event was the development of the [WorldPop API](https://github.com/codeforresilience/worldpop-api), designed to facilitate access to 
population data. This tool allows users to query area population statistics from the WorldPop dataset, 
providing valuable insights for planning and response strategies in disaster-prone regions. 
By automating the retrieval of demographic information, the API supports informed decision-making and 
efficient resource allocation during emergencies.

Another key project was the [Weather Dashboard](https://github.com/codeforresilience/weatherDashboard), tailored to provide real-time weather forecasts for Tandale,
a neighborhood in Dar es Salaam. This dashboard offers meteorological data, enabling residents 
and authorities to monitor weather conditions and prepare for potential hazards. The tool exemplifies how 
localized information systems can empower communities to respond proactively to environmental challenges.

These initiatives underscore the potential of collaborative efforts in leveraging technology for disaster resilience.
By combining local expertise with innovative tools, the projects developed at the Buni Innovation Hub demonstrate a 
promising path toward a more resilient Tanzania!


![Team lead interviewed for Code for Resilience Tanzania Program](https://raw.githubusercontent.com/samweli/jekyll-now/master/images/cfr_interview.jpg-large)
_Samweli (Team Lead) getting interviewed for the Code for Resilience Tanzania Program_

[Video](https://www.youtube.com/watch?v=KYnkZE9r0UQ&t=6s)]]></content><author><name>Samweli Mwakisambwe</name><email>smwltwesa6@gmail.com</email></author><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Collection of Daladala Routes</title><link href="http://0.0.0.0:4000/Daladala-Routes/" rel="alternate" type="text/html" title="Collection of Daladala Routes" /><published>2016-04-30T00:00:00+00:00</published><updated>2016-04-30T00:00:00+00:00</updated><id>http://0.0.0.0:4000/Daladala-Routes</id><content type="html" xml:base="http://0.0.0.0:4000/Daladala-Routes/"><![CDATA[![Dar es salaam transport routes (Bus routes in red)](https://raw.githubusercontent.com/samweli/jekyll-now/master/images/bus_routes.png)

_Map of public transport in Dar es salaam [link](https://api.mapbox.com/styles/v1/samtwesa/cijptupyz002d94kq81o26eww.html?fresh=true&title=true&access_token=pk.eyJ1Ijoic2FtdHdlc2EiLCJhIjoiZTc1OTQ4ODE0ZmY2MzY0MGYwMDNjOWNlYTYxMjU4NDYifQ.F1zCcOYqpXWd4C9l9xqvEQ#19.3/-6.816097/39.280324/0)_

## Dar es salaam Transport

Dar es Salaam’s public transport system is primarily built around Daladala minibuses, which form the backbone of daily commuting for the majority of the city's residents. In addition to Daladalas, the city also operates a ferry service across the harbor, a commuter train, and a modern Bus Rapid Transit (BRT) system known as DART (Dar Rapid Transit), which began operations in 2016 to improve urban mobility.

Back in 2015, as part of the Ramani Huria team, we collaborated with [ally](http://www.door2door.io), a transport and mobility-focused company, on a project to map the entire Daladala minibuses network of Dar es Salaam. This was an initiative aimed at bringing greater visibility and structure to the informal and semi-formal transport system that millions rely on every day.

Our main task was to organize and manage teams of local mappers, assigning them specific bus routes across the city to document. These mappers would ride Daladalas, recording routes and frequencies using GPS-enabled tools. This data collection was essential for building a comprehensive open dataset of the city's transport network.

The project not only helped visualize the complex web of routes but also laid the groundwork for future urban planning, route optimization, and the integration of digital transport tools. It was one of the early examples in the region of using open mapping and data science to make cities more accessible and livable.


![Mappers](https://raw.githubusercontent.com/samweli/jekyll-now/master/images/daladala_mapping.png)

_Mappers boarding Daladala buses to map routes_

[Here](https://samweli.github.io/dar-bus-tracking) is a live demo of the bus route data that were collected, showing the mapping process in action. This interactive map showcases the actual tracks recorded by mappers as they go through different Daladala routes throughout the city — a powerful visual representation of just how extensive and vital this transport network is.

Additionally, we documented the entire project and made the data open for everyone. You can find a detailed overview of the project and its results, on the Dar es Salaam Transport Wiki hosted by OpenStreetMap. This serves as a valuable resource for anyone looking to understand urban transport mapping or to replicate similar projects in other cities.
The wiki for the project can be found here [transport wiki](https://wiki.openstreetmap.org/wiki/Dar_es_Salaam/Transport).]]></content><author><name>Samweli Mwakisambwe</name><email>smwltwesa6@gmail.com</email></author><summary type="html"><![CDATA[]]></summary></entry></feed>